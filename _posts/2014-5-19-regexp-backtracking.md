---
layout: post
title: 回溯
---
回溯是NFA最重要的性质

NFA依次处理各个子表达式或组成元素，遇到需要在两个可能成功的可能中进行选择的时候，它会选择其一，同时记住另一个，以备稍后可能的需要，这就是回溯。

需要作出选择的包括：量词、多选结构

如果选择其中一种途径，正则表达式余下的部分匹配失败，就会回溯到之前作出选择的地方， 选择其他的备用分支继续进行尝试。


## 回溯的选择

### 哪个分支应当首先选择

如果要在尝试匹配和跳过尝试之间选择，对于匹配优先量词，引擎会优先选择进行尝试，对于忽略优先量词，引擎会优先选择跳过尝试。

#### 匹配优先量词

? * + {min,max}

#### 忽略优先量词

?? *? +? {min,max}?

###回溯时选择哪个保存的状态

回溯时选择距离当前最近存储的选项

## 回溯与匹配优先

###用ab?c 匹配abc

	-->ab?c
    -->abc

a匹配成功后，轮到b?,引擎需要决定：尝试b，还是跳过，因为？是匹配优先量词，所以会选择尝试。同时引擎会在保留一个备用状态(跳过b)

	ab?-->c
    a-->bc

保存好备用状态，引擎会继续向前，检查b

	a-->b?c
    a-->bc

匹配成功，继续检查c,匹配成功。备用状态不再需要了，所以不再保存他们

### 用ab?c 匹配ac

	-->ab?c
    -->ac

a匹配成功后，轮到b?,引擎需要决定：尝试b，还是跳过，因为？是匹配优先量词，所以会选择尝试。同时引擎会在保留一个备用状态(跳过b)

	ab?-->c
    a-->c
    
保存好备用状态，引擎会继续向前，检查b

	a-->b?c
    a-->c
    
不能匹配，回溯到最近保存的备用状态

	ab?-->c
    a-->c

匹配成功

### 用ab?c 匹配abX

前面的匹配过程跟上面的例子一样

ab?-->c
ab-->X

匹配失败，回溯到最近保存的备用状态

ab?-->c
a-->bX

匹配失败，如果还有其他保存状态会继续回溯，这里不存在其他保存状态，在字符串中当前位置开始的整个匹配就宣告失败。从字符串的下一个字符b重新开始尝试与正则ab?c匹配，直到从字符串所有位置的尝试都失败，整个匹配宣告失败。

## 回溯与占有优先量词和固化分组

### 固化分组

(?>....)

匹配进行到此结构之后，结构体中的所有备用状态都会被抛弃。也就是说括号内的子表达式中未尝试过的备用状态都不复存在了，回溯也不能选择其中的状态。

匹配优先和忽略优先都不会影响需要检测路径本身，而只会影响检测的顺序。固化分组则会放弃某些可能的路径。

### 占有优先量词

?+ *+ ++ {min,max}+

占有优先量词不交还已经匹配的字符。

## 环视中的回溯

只要环视结构的匹配尝试结束，它就不会留下任何备用状态

在环视结构内部，回溯时只能选择当前环视结构中的备用状态，如果需要回溯到当前的环视结构的起点以前，就会认为当前的子表达式无法匹配。

## 多选结构中的回溯

正则引擎会回溯到尚未尝试的多选分支的地方

传统型NFA，按照从左到右的顺序检查表达式中的多选分支，遇到能匹配的分支就匹配成功跳出多选结构继续匹配后面的部分。

DFA和POSIX NFA 总是匹配所有多选分支中能匹配最多文本的那个分支。

如果多选分支是有序的，而能匹配同样文本的多选分支不只一个时，就要小心安排多选分支的先后顺序。

	Jan(0?[1-9]|[12][0-9]|3[01])
    
    匹配文本 Jan31 is Dad's birthday
    
    //按顺序检查多选结构的NFA就只匹配Jan3

























